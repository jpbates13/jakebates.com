{"ast":null,"code":"import { Node, mergeAttributes, nodeInputRule } from '@tiptap/core';\nimport { TextSelection } from 'prosemirror-state';\nconst HorizontalRule = Node.create({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n\n  renderHTML(_ref) {\n    let {\n      HTMLAttributes\n    } = _ref;\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => _ref2 => {\n        let {\n          chain\n        } = _ref2;\n        return chain().insertContent({\n          type: this.name\n        }) // set cursor after horizontal rule\n        .command(_ref3 => {\n          let {\n            tr,\n            dispatch\n          } = _ref3;\n\n          var _a;\n\n          if (dispatch) {\n            const {\n              parent,\n              pos\n            } = tr.selection.$from;\n            const posAfter = pos + 1;\n            const nodeAfter = tr.doc.nodeAt(posAfter);\n\n            if (nodeAfter) {\n              tr.setSelection(TextSelection.create(tr.doc, posAfter));\n            } else {\n              // add node after horizontal rule if it’s the end of the document\n              const node = (_a = parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter));\n              }\n            }\n\n            tr.scrollIntoView();\n          }\n\n          return true;\n        }).run();\n      }\n    };\n  },\n\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n\n});\nexport { HorizontalRule, HorizontalRule as default };","map":{"version":3,"sources":["../src/horizontal-rule.ts"],"names":[],"mappings":";;MAsBa,cAAc,GAAG,IAAI,CAAC,MAAL,CAAmC;AAC/D,EAAA,IAAI,EAAE,gBADyD;;AAG/D,EAAA,UAAU,GAAA;AACR,WAAO;AACL,MAAA,cAAc,EAAE;AADX,KAAP;AAGD,GAP8D;;AAS/D,EAAA,KAAK,EAAE,OATwD;;AAW/D,EAAA,SAAS,GAAA;AACP,WAAO,CACL;AAAE,MAAA,GAAG,EAAE;AAAP,KADK,CAAP;AAGD,GAf8D;;AAiB/D,EAAA,UAAU,OAAmB;AAAA,QAAlB;AAAE,MAAA;AAAF,KAAkB;AAC3B,WAAO,CAAC,IAAD,EAAO,eAAe,CAAC,KAAK,OAAL,CAAa,cAAd,EAA8B,cAA9B,CAAtB,CAAP;AACD,GAnB8D;;AAqB/D,EAAA,WAAW,GAAA;AACT,WAAO;AACL,MAAA,iBAAiB,EAAE,MAAM,SAAU;AAAA,YAAT;AAAE,UAAA;AAAF,SAAS;AACjC,eAAO,KAAK,GACT,aADI,CACU;AAAE,UAAA,IAAI,EAAE,KAAK;AAAb,SADV,E;AAAA,SAGJ,OAHI,CAGI,SAAiB;AAAA,cAAhB;AAAE,YAAA,EAAF;AAAM,YAAA;AAAN,WAAgB;;;;AACxB,cAAI,QAAJ,EAAc;AACZ,kBAAM;AAAE,cAAA,MAAF;AAAU,cAAA;AAAV,gBAAkB,EAAE,CAAC,SAAH,CAAa,KAArC;AACA,kBAAM,QAAQ,GAAG,GAAG,GAAG,CAAvB;AACA,kBAAM,SAAS,GAAG,EAAE,CAAC,GAAH,CAAO,MAAP,CAAc,QAAd,CAAlB;;AAEA,gBAAI,SAAJ,EAAe;AACb,cAAA,EAAE,CAAC,YAAH,CAAgB,aAAa,CAAC,MAAd,CAAqB,EAAE,CAAC,GAAxB,EAA6B,QAA7B,CAAhB;AACD,aAFD,MAEO;;AAEL,oBAAM,IAAI,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,IAAP,CAAY,YAAZ,CAAyB,WAAzB,MAAoC,IAApC,IAAoC,EAAA,KAAA,KAAA,CAApC,GAAoC,KAAA,CAApC,GAAoC,EAAA,CAAE,MAAF,EAAjD;;AAEA,kBAAI,IAAJ,EAAU;AACR,gBAAA,EAAE,CAAC,MAAH,CAAU,QAAV,EAAoB,IAApB;AACA,gBAAA,EAAE,CAAC,YAAH,CAAgB,aAAa,CAAC,MAAd,CAAqB,EAAE,CAAC,GAAxB,EAA6B,QAA7B,CAAhB;AACD;AACF;;AAED,YAAA,EAAE,CAAC,cAAH;AACD;;AAED,iBAAO,IAAP;AACD,SAzBI,EA0BJ,GA1BI,EAAP;AA2BD;AA7BI,KAAP;AA+BD,GArD8D;;AAuD/D,EAAA,aAAa,GAAA;AACX,WAAO,CACL,aAAa,CAAC;AACZ,MAAA,IAAI,EAAE,6BADM;AAEZ,MAAA,IAAI,EAAE,KAAK;AAFC,KAAD,CADR,CAAP;AAMD;;AA9D8D,CAAnC,C","sourcesContent":["import {\n  Node,\n  nodeInputRule,\n  mergeAttributes,\n} from '@tiptap/core'\nimport { TextSelection } from 'prosemirror-state'\n\nexport interface HorizontalRuleOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       */\n      setHorizontalRule: () => ReturnType,\n    }\n  }\n}\n\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [\n      { tag: 'hr' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain }) => {\n        return chain()\n          .insertContent({ type: this.name })\n          // set cursor after horizontal rule\n          .command(({ tr, dispatch }) => {\n            if (dispatch) {\n              const { parent, pos } = tr.selection.$from\n              const posAfter = pos + 1\n              const nodeAfter = tr.doc.nodeAt(posAfter)\n\n              if (nodeAfter) {\n                tr.setSelection(TextSelection.create(tr.doc, posAfter))\n              } else {\n                // add node after horizontal rule if it’s the end of the document\n                const node = parent.type.contentMatch.defaultType?.create()\n\n                if (node) {\n                  tr.insert(posAfter, node)\n                  tr.setSelection(TextSelection.create(tr.doc, posAfter))\n                }\n              }\n\n              tr.scrollIntoView()\n            }\n\n            return true\n          })\n          .run()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}