{"ast":null,"code":"import { Node, mergeAttributes } from '@tiptap/core';\nconst HardBreak = Node.create({\n  name: 'hardBreak',\n\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {}\n    };\n  },\n\n  inline: true,\n  group: 'inline',\n  selectable: false,\n\n  parseHTML() {\n    return [{\n      tag: 'br'\n    }];\n  },\n\n  renderHTML(_ref) {\n    let {\n      HTMLAttributes\n    } = _ref;\n    return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n\n  renderText() {\n    return '\\n';\n  },\n\n  addCommands() {\n    return {\n      setHardBreak: () => _ref2 => {\n        let {\n          commands,\n          chain,\n          state,\n          editor\n        } = _ref2;\n        return commands.first([() => commands.exitCode(), () => commands.command(() => {\n          const {\n            selection,\n            storedMarks\n          } = state;\n\n          if (selection.$from.parent.type.spec.isolating) {\n            return false;\n          }\n\n          const {\n            keepMarks\n          } = this.options;\n          const {\n            splittableMarks\n          } = editor.extensionManager;\n          const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n          return chain().insertContent({\n            type: this.name\n          }).command(_ref3 => {\n            let {\n              tr,\n              dispatch\n            } = _ref3;\n\n            if (dispatch && marks && keepMarks) {\n              const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n              tr.ensureMarks(filteredMarks);\n            }\n\n            return true;\n          }).run();\n        })]);\n      }\n    };\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Enter': () => this.editor.commands.setHardBreak(),\n      'Shift-Enter': () => this.editor.commands.setHardBreak()\n    };\n  }\n\n});\nexport { HardBreak, HardBreak as default };","map":{"version":3,"sources":["../src/hard-break.ts"],"names":[],"mappings":";MAkBa,SAAS,GAAG,IAAI,CAAC,MAAL,CAA8B;AACrD,EAAA,IAAI,EAAE,WAD+C;;AAGrD,EAAA,UAAU,GAAA;AACR,WAAO;AACL,MAAA,SAAS,EAAE,IADN;AAEL,MAAA,cAAc,EAAE;AAFX,KAAP;AAID,GARoD;;AAUrD,EAAA,MAAM,EAAE,IAV6C;AAYrD,EAAA,KAAK,EAAE,QAZ8C;AAcrD,EAAA,UAAU,EAAE,KAdyC;;AAgBrD,EAAA,SAAS,GAAA;AACP,WAAO,CACL;AAAE,MAAA,GAAG,EAAE;AAAP,KADK,CAAP;AAGD,GApBoD;;AAsBrD,EAAA,UAAU,OAAmB;AAAA,QAAlB;AAAE,MAAA;AAAF,KAAkB;AAC3B,WAAO,CAAC,IAAD,EAAO,eAAe,CAAC,KAAK,OAAL,CAAa,cAAd,EAA8B,cAA9B,CAAtB,CAAP;AACD,GAxBoD;;AA0BrD,EAAA,UAAU,GAAA;AACR,WAAO,IAAP;AACD,GA5BoD;;AA8BrD,EAAA,WAAW,GAAA;AACT,WAAO;AACL,MAAA,YAAY,EAAE,MAAM,SAKnB;AAAA,YALoB;AACnB,UAAA,QADmB;AAEnB,UAAA,KAFmB;AAGnB,UAAA,KAHmB;AAInB,UAAA;AAJmB,SAKpB;AACC,eAAO,QAAQ,CAAC,KAAT,CAAe,CACpB,MAAM,QAAQ,CAAC,QAAT,EADc,EAEpB,MAAM,QAAQ,CAAC,OAAT,CAAiB,MAAA;AACrB,gBAAM;AAAE,YAAA,SAAF;AAAa,YAAA;AAAb,cAA6B,KAAnC;;AAEA,cAAI,SAAS,CAAC,KAAV,CAAgB,MAAhB,CAAuB,IAAvB,CAA4B,IAA5B,CAAiC,SAArC,EAAgD;AAC9C,mBAAO,KAAP;AACD;;AAED,gBAAM;AAAE,YAAA;AAAF,cAAgB,KAAK,OAA3B;AACA,gBAAM;AAAE,YAAA;AAAF,cAAsB,MAAM,CAAC,gBAAnC;AACA,gBAAM,KAAK,GAAG,WAAW,IACnB,SAAS,CAAC,GAAV,CAAc,YAAd,IAA8B,SAAS,CAAC,KAAV,CAAgB,KAAhB,EADpC;AAGA,iBAAO,KAAK,GACT,aADI,CACU;AAAE,YAAA,IAAI,EAAE,KAAK;AAAb,WADV,EAEJ,OAFI,CAEI,SAAiB;AAAA,gBAAhB;AAAE,cAAA,EAAF;AAAM,cAAA;AAAN,aAAgB;;AACxB,gBAAI,QAAQ,IAAI,KAAZ,IAAqB,SAAzB,EAAoC;AAClC,oBAAM,aAAa,GAAG,KAAK,CACxB,MADmB,CACZ,IAAI,IAAI,eAAe,CAAC,QAAhB,CAAyB,IAAI,CAAC,IAAL,CAAU,IAAnC,CADI,CAAtB;AAGA,cAAA,EAAE,CAAC,WAAH,CAAe,aAAf;AACD;;AAED,mBAAO,IAAP;AACD,WAXI,EAYJ,GAZI,EAAP;AAaD,SAzBK,CAFc,CAAf,CAAP;AA6BD;AApCI,KAAP;AAsCD,GArEoD;;AAuErD,EAAA,oBAAoB,GAAA;AAClB,WAAO;AACL,mBAAa,MAAM,KAAK,MAAL,CAAY,QAAZ,CAAqB,YAArB,EADd;AAEL,qBAAe,MAAM,KAAK,MAAL,CAAY,QAAZ,CAAqB,YAArB;AAFhB,KAAP;AAID;;AA5EoD,CAA9B,C","sourcesContent":["import { Node, mergeAttributes } from '@tiptap/core'\n\nexport interface HardBreakOptions {\n  keepMarks: boolean,\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    hardBreak: {\n      /**\n       * Add a hard break\n       */\n      setHardBreak: () => ReturnType,\n    }\n  }\n}\n\nexport const HardBreak = Node.create<HardBreakOptions>({\n  name: 'hardBreak',\n\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {},\n    }\n  },\n\n  inline: true,\n\n  group: 'inline',\n\n  selectable: false,\n\n  parseHTML() {\n    return [\n      { tag: 'br' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  renderText() {\n    return '\\n'\n  },\n\n  addCommands() {\n    return {\n      setHardBreak: () => ({\n        commands,\n        chain,\n        state,\n        editor,\n      }) => {\n        return commands.first([\n          () => commands.exitCode(),\n          () => commands.command(() => {\n            const { selection, storedMarks } = state\n\n            if (selection.$from.parent.type.spec.isolating) {\n              return false\n            }\n\n            const { keepMarks } = this.options\n            const { splittableMarks } = editor.extensionManager\n            const marks = storedMarks\n              || (selection.$to.parentOffset && selection.$from.marks())\n\n            return chain()\n              .insertContent({ type: this.name })\n              .command(({ tr, dispatch }) => {\n                if (dispatch && marks && keepMarks) {\n                  const filteredMarks = marks\n                    .filter(mark => splittableMarks.includes(mark.type.name))\n\n                  tr.ensureMarks(filteredMarks)\n                }\n\n                return true\n              })\n              .run()\n          }),\n        ])\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Enter': () => this.editor.commands.setHardBreak(),\n      'Shift-Enter': () => this.editor.commands.setHardBreak(),\n    }\n  },\n})\n"]},"metadata":{},"sourceType":"module"}