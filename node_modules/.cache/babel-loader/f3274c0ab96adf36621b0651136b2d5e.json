{"ast":null,"code":"import { Node, textblockTypeInputRule } from '@tiptap/core';\nimport { Plugin, PluginKey, TextSelection } from 'prosemirror-state';\nconst backtickInputRegex = /^```(?<language>[a-z]*)?[\\s\\n]$/;\nconst tildeInputRegex = /^~~~(?<language>[a-z]*)?[\\s\\n]$/;\nconst CodeBlock = Node.create({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      HTMLAttributes: {}\n    };\n  },\n\n  content: 'text*',\n  marks: '',\n  group: 'block',\n  code: true,\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: null,\n        parseHTML: element => {\n          var _a;\n\n          const {\n            languageClassPrefix\n          } = this.options;\n          const classNames = [...(((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || [])];\n          const languages = classNames.filter(className => className.startsWith(languageClassPrefix)).map(className => className.replace(languageClassPrefix, ''));\n          const language = languages[0];\n\n          if (!language) {\n            return null;\n          }\n\n          return language;\n        },\n        renderHTML: attributes => {\n          if (!attributes.language) {\n            return null;\n          }\n\n          return {\n            class: this.options.languageClassPrefix + attributes.language\n          };\n        }\n      }\n    };\n  },\n\n  parseHTML() {\n    return [{\n      tag: 'pre',\n      preserveWhitespace: 'full'\n    }];\n  },\n\n  renderHTML(_ref) {\n    let {\n      HTMLAttributes\n    } = _ref;\n    return ['pre', this.options.HTMLAttributes, ['code', HTMLAttributes, 0]];\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock: attributes => _ref2 => {\n        let {\n          commands\n        } = _ref2;\n        return commands.setNode(this.name, attributes);\n      },\n      toggleCodeBlock: attributes => _ref3 => {\n        let {\n          commands\n        } = _ref3;\n        return commands.toggleNode(this.name, 'paragraph', attributes);\n      }\n    };\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const {\n          empty,\n          $anchor\n        } = this.editor.state.selection;\n        const isAtStart = $anchor.pos === 1;\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false;\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes();\n        }\n\n        return false;\n      },\n      // escape node on triple enter\n      Enter: _ref4 => {\n        let {\n          editor\n        } = _ref4;\n        const {\n          state\n        } = editor;\n        const {\n          selection\n        } = state;\n        const {\n          $from,\n          empty\n        } = selection;\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n');\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false;\n        }\n\n        return editor.chain().command(_ref5 => {\n          let {\n            tr\n          } = _ref5;\n          tr.delete($from.pos - 2, $from.pos);\n          return true;\n        }).exitCode().run();\n      },\n      // escape node on arrow down\n      ArrowDown: _ref6 => {\n        let {\n          editor\n        } = _ref6;\n        const {\n          state\n        } = editor;\n        const {\n          selection,\n          doc\n        } = state;\n        const {\n          $from,\n          empty\n        } = selection;\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n\n        if (!isAtEnd) {\n          return false;\n        }\n\n        const after = $from.after();\n\n        if (after === undefined) {\n          return false;\n        }\n\n        const nodeAfter = doc.nodeAt(after);\n\n        if (nodeAfter) {\n          return false;\n        }\n\n        return editor.commands.exitCode();\n      }\n    };\n  },\n\n  addInputRules() {\n    return [textblockTypeInputRule({\n      find: backtickInputRegex,\n      type: this.type,\n      getAttributes: _ref7 => {\n        let {\n          groups\n        } = _ref7;\n        return groups;\n      }\n    }), textblockTypeInputRule({\n      find: tildeInputRegex,\n      type: this.type,\n      getAttributes: _ref8 => {\n        let {\n          groups\n        } = _ref8;\n        return groups;\n      }\n    })];\n  },\n\n  addProseMirrorPlugins() {\n    return [// this plugin creates a code block for pasted content from VS Code\n    // we can also detect the copied code language\n    new Plugin({\n      key: new PluginKey('codeBlockVSCodeHandler'),\n      props: {\n        handlePaste: (view, event) => {\n          if (!event.clipboardData) {\n            return false;\n          } // donâ€™t create a new code block within code blocks\n\n\n          if (this.editor.isActive(this.type.name)) {\n            return false;\n          }\n\n          const text = event.clipboardData.getData('text/plain');\n          const vscode = event.clipboardData.getData('vscode-editor-data');\n          const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n          const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\n\n          if (!text || !language) {\n            return false;\n          }\n\n          const {\n            tr\n          } = view.state; // create an empty code block\n\n          tr.replaceSelectionWith(this.type.create({\n            language\n          })); // put cursor inside the newly created code block\n\n          tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2)))); // add text to code block\n          // strip carriage return chars from text pasted as code\n          // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n\n          tr.insertText(text.replace(/\\r\\n?/g, '\\n')); // store meta information\n          // this is useful for other plugins that depends on the paste event\n          // like the paste rule plugin\n\n          tr.setMeta('paste', true);\n          view.dispatch(tr);\n          return true;\n        }\n      }\n    })];\n  }\n\n});\nexport { CodeBlock, backtickInputRegex, CodeBlock as default, tildeInputRegex };","map":{"version":3,"sources":["../src/code-block.ts"],"names":[],"mappings":"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","sourcesContent":["import { Node, textblockTypeInputRule } from '@tiptap/core'\nimport { Plugin, PluginKey, TextSelection } from 'prosemirror-state'\n\nexport interface CodeBlockOptions {\n  languageClassPrefix: string,\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    codeBlock: {\n      /**\n       * Set a code block\n       */\n      setCodeBlock: (attributes?: { language: string }) => ReturnType,\n      /**\n       * Toggle a code block\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => ReturnType,\n    }\n  }\n}\n\nexport const backtickInputRegex = /^```(?<language>[a-z]*)?[\\s\\n]$/\nexport const tildeInputRegex = /^~~~(?<language>[a-z]*)?[\\s\\n]$/\n\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: null,\n        parseHTML: element => {\n          const { languageClassPrefix } = this.options\n          const classNames = [...element.firstElementChild?.classList || []]\n          const languages = classNames\n            .filter(className => className.startsWith(languageClassPrefix))\n            .map(className => className.replace(languageClassPrefix, ''))\n          const language = languages[0]\n\n          if (!language) {\n            return null\n          }\n\n          return language\n        },\n        renderHTML: attributes => {\n          if (!attributes.language) {\n            return null\n          }\n\n          return {\n            class: this.options.languageClassPrefix + attributes.language,\n          }\n        },\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['pre', this.options.HTMLAttributes, ['code', HTMLAttributes, 0]]\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock: attributes => ({ commands }) => {\n        return commands.setNode(this.name, attributes)\n      },\n      toggleCodeBlock: attributes => ({ commands }) => {\n        return commands.toggleNode(this.name, 'paragraph', attributes)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n\n      // escape node on triple enter\n      Enter: ({ editor }) => {\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n')\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false\n        }\n\n        return editor\n          .chain()\n          .command(({ tr }) => {\n            tr.delete($from.pos - 2, $from.pos)\n\n            return true\n          })\n          .exitCode()\n          .run()\n      },\n\n      // escape node on arrow down\n      ArrowDown: ({ editor }) => {\n        const { state } = editor\n        const { selection, doc } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n\n        if (!isAtEnd) {\n          return false\n        }\n\n        const after = $from.after()\n\n        if (after === undefined) {\n          return false\n        }\n\n        const nodeAfter = doc.nodeAt(after)\n\n        if (nodeAfter) {\n          return false\n        }\n\n        return editor.commands.exitCode()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: ({ groups }) => groups,\n      }),\n      textblockTypeInputRule({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: ({ groups }) => groups,\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new Plugin({\n        key: new PluginKey('codeBlockVSCodeHandler'),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false\n            }\n\n            // donâ€™t create a new code block within code blocks\n            if (this.editor.isActive(this.type.name)) {\n              return false\n            }\n\n            const text = event.clipboardData.getData('text/plain')\n            const vscode = event.clipboardData.getData('vscode-editor-data')\n            const vscodeData = vscode\n              ? JSON.parse(vscode)\n              : undefined\n            const language = vscodeData?.mode\n\n            if (!text || !language) {\n              return false\n            }\n\n            const { tr } = view.state\n\n            // create an empty code block\n            tr.replaceSelectionWith(this.type.create({ language }))\n\n            // put cursor inside the newly created code block\n            tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))))\n\n            // add text to code block\n            // strip carriage return chars from text pasted as code\n            // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n            tr.insertText(text.replace(/\\r\\n?/g, '\\n'))\n\n            // store meta information\n            // this is useful for other plugins that depends on the paste event\n            // like the paste rule plugin\n            tr.setMeta('paste', true)\n\n            view.dispatch(tr)\n\n            return true\n          },\n        },\n      }),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}