{"ast":null,"code":"import { isTextSelection, isNodeSelection, posToDOMRect, Extension } from '@tiptap/core';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport tippy from 'tippy.js';\n\nclass BubbleMenuView {\n  constructor(_ref) {\n    let {\n      editor,\n      element,\n      view,\n      tippyOptions = {},\n      shouldShow\n    } = _ref;\n    this.preventHide = false;\n\n    this.shouldShow = _ref2 => {\n      let {\n        view,\n        state,\n        from,\n        to\n      } = _ref2;\n      const {\n        doc,\n        selection\n      } = state;\n      const {\n        empty\n      } = selection; // Sometime check for `empty` is not enough.\n      // Doubleclick an empty paragraph returns a node size of 2.\n      // So we check also for an empty text size.\n\n      const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection);\n\n      if (!view.hasFocus() || empty || isEmptyTextBlock) {\n        return false;\n      }\n\n      return true;\n    };\n\n    this.mousedownHandler = () => {\n      this.preventHide = true;\n    };\n\n    this.dragstartHandler = () => {\n      this.hide();\n    };\n\n    this.focusHandler = () => {\n      // we use `setTimeout` to make sure `selection` is already updated\n      setTimeout(() => this.update(this.editor.view));\n    };\n\n    this.blurHandler = _ref3 => {\n      let {\n        event\n      } = _ref3;\n\n      var _a;\n\n      if (this.preventHide) {\n        this.preventHide = false;\n        return;\n      }\n\n      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n        return;\n      }\n\n      this.hide();\n    };\n\n    this.editor = editor;\n    this.element = element;\n    this.view = view;\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow;\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler);\n    this.editor.on('focus', this.focusHandler);\n    this.editor.on('blur', this.blurHandler);\n    this.tippyOptions = tippyOptions; // Detaches menu content from its current parent\n\n    this.element.remove();\n    this.element.style.visibility = 'visible';\n  }\n\n  createTooltip() {\n    const {\n      element: editorElement\n    } = this.editor.options;\n    const editorIsAttached = !!editorElement.parentElement;\n\n    if (this.tippy || !editorIsAttached) {\n      return;\n    }\n\n    this.tippy = tippy(editorElement, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...this.tippyOptions\n    }); // maybe we have to hide tippy on its own blur event as well\n\n    if (this.tippy.popper.firstChild) {\n      this.tippy.popper.firstChild.addEventListener('blur', event => {\n        this.blurHandler({\n          event\n        });\n      });\n    }\n  }\n\n  update(view, oldState) {\n    var _a, _b;\n\n    const {\n      state,\n      composing\n    } = view;\n    const {\n      doc,\n      selection\n    } = state;\n    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n\n    if (composing || isSame) {\n      return;\n    }\n\n    this.createTooltip(); // support for CellSelections\n\n    const {\n      ranges\n    } = selection;\n    const from = Math.min(...ranges.map(range => range.$from.pos));\n    const to = Math.max(...ranges.map(range => range.$to.pos));\n    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n      editor: this.editor,\n      view,\n      state,\n      oldState,\n      from,\n      to\n    });\n\n    if (!shouldShow) {\n      this.hide();\n      return;\n    }\n\n    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n      getReferenceClientRect: () => {\n        if (isNodeSelection(state.selection)) {\n          const node = view.nodeDOM(from);\n\n          if (node) {\n            return node.getBoundingClientRect();\n          }\n        }\n\n        return posToDOMRect(view, from, to);\n      }\n    });\n    this.show();\n  }\n\n  show() {\n    var _a;\n\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n  }\n\n  hide() {\n    var _a;\n\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n  }\n\n  destroy() {\n    var _a;\n\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();\n    this.element.removeEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\n    this.editor.off('focus', this.focusHandler);\n    this.editor.off('blur', this.blurHandler);\n  }\n\n}\n\nconst BubbleMenuPlugin = options => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new BubbleMenuView({\n      view,\n      ...options\n    })\n  });\n};\n\nconst BubbleMenu = Extension.create({\n  name: 'bubbleMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      tippyOptions: {},\n      pluginKey: 'bubbleMenu',\n      shouldShow: null\n    };\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return [];\n    }\n\n    return [BubbleMenuPlugin({\n      pluginKey: this.options.pluginKey,\n      editor: this.editor,\n      element: this.options.element,\n      tippyOptions: this.options.tippyOptions,\n      shouldShow: this.options.shouldShow\n    })];\n  }\n\n});\nexport { BubbleMenu, BubbleMenuPlugin, BubbleMenuView, BubbleMenu as default };","map":{"version":3,"sources":["../src/bubble-menu-plugin.ts","../src/bubble-menu.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Editor,\n  posToDOMRect,\n  isTextSelection,\n  isNodeSelection,\n} from '@tiptap/core'\nimport { EditorState, Plugin, PluginKey } from 'prosemirror-state'\nimport { EditorView } from 'prosemirror-view'\nimport tippy, { Instance, Props } from 'tippy.js'\n\nexport interface BubbleMenuPluginProps {\n  pluginKey: PluginKey | string,\n  editor: Editor,\n  element: HTMLElement,\n  tippyOptions?: Partial<Props>,\n  shouldShow?: ((props: {\n    editor: Editor,\n    view: EditorView,\n    state: EditorState,\n    oldState?: EditorState,\n    from: number,\n    to: number,\n  }) => boolean) | null,\n}\n\nexport type BubbleMenuViewProps = BubbleMenuPluginProps & {\n  view: EditorView,\n}\n\nexport class BubbleMenuView {\n  public editor: Editor\n\n  public element: HTMLElement\n\n  public view: EditorView\n\n  public preventHide = false\n\n  public tippy: Instance | undefined\n\n  public tippyOptions?: Partial<Props>\n\n  public shouldShow: Exclude<BubbleMenuPluginProps['shouldShow'], null> = ({\n    view,\n    state,\n    from,\n    to,\n  }) => {\n    const { doc, selection } = state\n    const { empty } = selection\n\n    // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n    const isEmptyTextBlock = !doc.textBetween(from, to).length\n      && isTextSelection(state.selection)\n\n    if (\n      !view.hasFocus()\n      || empty\n      || isEmptyTextBlock\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  constructor({\n    editor,\n    element,\n    view,\n    tippyOptions = {},\n    shouldShow,\n  }: BubbleMenuViewProps) {\n    this.editor = editor\n    this.element = element\n    this.view = view\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler)\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n    this.tippyOptions = tippyOptions\n    // Detaches menu content from its current parent\n    this.element.remove()\n    this.element.style.visibility = 'visible'\n  }\n\n  mousedownHandler = () => {\n    this.preventHide = true\n  }\n\n  dragstartHandler = () => {\n    this.hide()\n  }\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.editor.view))\n  }\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.preventHide) {\n      this.preventHide = false\n\n      return\n    }\n\n    if (\n      event?.relatedTarget\n      && this.element.parentNode?.contains(event.relatedTarget as Node)\n    ) {\n      return\n    }\n\n    this.hide()\n  }\n\n  createTooltip() {\n    const { element: editorElement } = this.editor.options\n    const editorIsAttached = !!editorElement.parentElement\n\n    if (this.tippy || !editorIsAttached) {\n      return\n    }\n\n    this.tippy = tippy(editorElement, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...this.tippyOptions,\n    })\n\n    // maybe we have to hide tippy on its own blur event as well\n    if (this.tippy.popper.firstChild) {\n      (this.tippy.popper.firstChild as HTMLElement).addEventListener('blur', event => {\n        this.blurHandler({ event })\n      })\n    }\n  }\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state, composing } = view\n    const { doc, selection } = state\n    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection)\n\n    if (composing || isSame) {\n      return\n    }\n\n    this.createTooltip()\n\n    // support for CellSelections\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      view,\n      state,\n      oldState,\n      from,\n      to,\n    })\n\n    if (!shouldShow) {\n      this.hide()\n\n      return\n    }\n\n    this.tippy?.setProps({\n      getReferenceClientRect: () => {\n        if (isNodeSelection(state.selection)) {\n          const node = view.nodeDOM(from) as HTMLElement\n\n          if (node) {\n            return node.getBoundingClientRect()\n          }\n        }\n\n        return posToDOMRect(view, from, to)\n      },\n    })\n\n    this.show()\n  }\n\n  show() {\n    this.tippy?.show()\n  }\n\n  hide() {\n    this.tippy?.hide()\n  }\n\n  destroy() {\n    this.tippy?.destroy()\n    this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler)\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n  }\n}\n\nexport const BubbleMenuPlugin = (options: BubbleMenuPluginProps) => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string'\n      ? new PluginKey(options.pluginKey)\n      : options.pluginKey,\n    view: view => new BubbleMenuView({ view, ...options }),\n  })\n}\n","import { Extension } from '@tiptap/core'\nimport { BubbleMenuPlugin, BubbleMenuPluginProps } from './bubble-menu-plugin'\n\nexport type BubbleMenuOptions = Omit<BubbleMenuPluginProps, 'editor' | 'element'> & {\n  element: HTMLElement | null,\n}\n\nexport const BubbleMenu = Extension.create<BubbleMenuOptions>({\n  name: 'bubbleMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      tippyOptions: {},\n      pluginKey: 'bubbleMenu',\n      shouldShow: null,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return []\n    }\n\n    return [\n      BubbleMenuPlugin({\n        pluginKey: this.options.pluginKey,\n        editor: this.editor,\n        element: this.options.element,\n        tippyOptions: this.options.tippyOptions,\n        shouldShow: this.options.shouldShow,\n      }),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}